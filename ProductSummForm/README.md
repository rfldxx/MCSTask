# Содержание
 - [Решение](#Решение)
 - [Задание](#Задание)

# Решение

### Structure

PS-форма реализована с помощью списка списков:
 * сама PS-форма - это список слагаемых (monom*), 
 * а каждое слагаемое в свою очередь - это список множителей (list*)

```c
struct list_ {
    char   elem;
    struct list_* next;
};

struct monom_ {
    int    coef;
    list*  variables;
    struct monom_* next;
};
```

Пустой список слагаемых - корректен. Он считается как 0.

Переменные - это только буквы a-z.
В списке множителей (list*) переменные храняться в порядке возрастания: \
``` 'a' -> 'a' -> 'b' -> 'c' -> 0 ```

---


### Operations

Все необходимые функции для работы с PS-формами подключаются
через ```#include "monom.h"```


Операции [sum, sub, is_equal] делаются in-place - т.е. после их
применения их аргументы могут поменяться и поэтому 
в main.c некоторая возня с этим.

---


### In&Out

Обнаружилось, что scanf("%d") работает не много не очевидно,
когда считывается:  "+"  или  "-"  (только знак). \
В этом случае scanf возвращает 0, хоть при этом символ знака считан из потока.

Это вызывало проблемы с обнаружением/считыванием:
 - " - a "
 - " a + + b "

Для обхода этого была реализована функия scan_number().


Вывод позволяет отображать степени, для этого надо определить макрос:
```c
#define SHOW_WITH_POWER
```
до подключения  ```"monom.h"``` 
(например можно сделать при компиляции, добавив флаг ```-DSHOW_WITH_POWER```)

---


### Tests

Есть подготовленные тестовые файлы - они обходятся скриптом ```scroll.sh``` (см. папку [tests](tests/)).

Так же создана программа ```binom_test.c``` которая проверяет
верность раскрытия скобок в выражении $(a-b)^n$. \
Для этого PS-форма равная "1" постепенно домнажается на "a-b"
с проверкой на каждом шаге.









# Задание
Рекомендуется уделить внимание отладке вашего решения:
- продумайте все краевые случаи и подготовьте соответствующие входные данные;
- подготовьте ~10 файлов с различными входными данными и столько же с эталонной выдачей, напишите скрипт, автоматизирующий проверку работы вашей программы на этих входных данных;
- протестируйте работу вашей программы, собранной в отладочном режиме с AddressSanitizer (есть в gcc и clang) и MemorySanitizer (есть только в clang);


### Информация
В оптимизирующем компиляторе нередко возникает необходимость представить вычисления в символьном виде.
Для этого используются PS-формы (PSF - Product-Summ Form),
которые позволяют представить арифметическое выражение в виде
суммы произведений. Пример PS-формы:
$$8 + x - 5 \cdot y + 3 \cdot x \cdot y$$
где $x$ и $y$ - некоторые переменные.
В PS-формах используется только три арифметических оператора:
$+$, $-$ и $\times$ .
Возведения в степень нет, вместо него используется многократное
умножение, например $x \cdot x \cdot x$.
Скобки не используются.

Мы будем рассматривать только PS-формы в каноническом виде,
которые обладают следующими свойствами:
- константные множители в слагаемых могут находиться только в начале слагаемого; как следствие, в слагаемом может быть только один константный множитель;
- PS-форма не упрощается, т.е. в ней нельзя сократить какие-либо слагаемые; например:\
  $x + y$ -- канонический вид\
  $2 \cdot x + y - x$ -- НЕ канонический вид (можно упростить до $x + y$)

За исключением указанного выше ограничения, порядок слагаемых
и множителей внутри слагаемого не имеют значения.\
Например, следующие PS-формы:\
$\hspace{20pt} x + y \cdot z$\
$\hspace{20pt} y \cdot z + x$\
$\hspace{20pt} z \cdot y + x$\
эквивалентны.

### Условия задачи
Необходимо реализовать простые операции над парой PS-форм:
- сложение
- вычитание
- умножение
- сравнение на равенство


На вход программе подаются три строки:
1) знак операции, которую необходимо выполнить над двумя PS-формами (+-*=)
2) первая PS-форма (в каноническом виде)
3) вторая PS-форма (в каноническом виде)


Все переменные однобуквенные. Константные множители целочисленные,
и могут быть как положительными, так и отрицательными.
Между слагаемыми и множителями может быть произвольное количество пробелов.

Программа должна выполнить указанное действие над парой PS-форм
и затем упростить полученный результат (привести к каноническому виду).
На выходе программа должна напечатать на экран результирующую
PS-форму (в случае +-*) либо результат сравнения:
```equal``` или ```not equal``` (в случае =).

Дополнительно:
1) PS-форма должна быть реализована с помощью списка списков:\
сама PS-форма - это список слагаемых, а каждое слагаемое в свою очередь - это список множителей.
2) На вход программе будут подаваться не очень большие PS-формы (до ~100 слагаемых, до 26 множителей в каждом), поэтому можно использовать алгоритмы с квадратичной алгоритмической сложностью.
3) Программа должна работать не дольше одной секунды.


### Примеры
```
Пример входного потока (1):
---------------------------
*
x + x*y + y
x - y

Вывод программы (1):
--------------------
x*x + x*x*y - x*y*y - y*y
```

```
Пример входного потока (2):
---------------------------
-
a + 3*y - b
-1*x + 3*y - 5*z

Вывод программы (2):
--------------------
a - b + x + 5*z
```

```
Пример входного потока (3):
---------------------------
=
-1*x + y*z
z * y - x

Вывод программы (3):
--------------------
equal
```

```
Пример входного потока (4):
---------------------------
=
x + y
y - x

Вывод программы (4):
--------------------
not equal
```

