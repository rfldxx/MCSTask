### Ошибки
1.1) is_pow_of_2 - ошибка, есть контрпример. \
1.2) Ломается при подаче на вход int'a.

2.1) Попробуйте вызвать get(10,8). У меня сломалось. \
2.2) Сомнительный результат:   
```
  uint64_t init_arr[] = { 0x1122334455667788, 0xbabadedacafebeef,
                          0x4354659710928523, 0xcafebabe8794abcd };
  bits my_bits(256, init_arr);
  my_bits.set(10, my_bits.get(0,8));
  std::cout << "my_bits = " << my_bits.str() << std::endl;
```

```
> my_bits = 8862265544332211EFBEFECADADEBABA2385921097655443CDAB9487BEBAFECA
```

3 ) Принято.


### Задание

* Реализовать функцию от аргумента $a$ интегрального типа, возвращающую
признак того, что $a$ является степенью двойки: 
$$f (a) == \{\exists i \in \N \cup {0} : a == 2^i\}.$$

$\text{ }$

* Реализовать класс битового вектора произвольной разрядности. \
Необходимые методы:
   - конструктор (разрядность, массив переменных интегрального типа);
   - разрядность ();
   - установить битовое поле (смещение, битвектор);
   - получить битовое поле (смещение, разрядность);
   - получить битовое поле (смещение, разрядность) в переменную
интегрального типа: отдельный вариант для битовых полей малой
разрядности (до 64 разрядов);
   - получить строковое представление в 16-ричном виде.
  Разрядное (битовое) поле битового вектора определяется номерами
позиций младшего и старшего разряда поля.

$\text{ }$

* Реализовать функцию, для данного набора входных элементов $\mathcal{A}$ 
возвращающую случайную выборку из $n$ элементов ( $n \le \text{size\_of} (\mathcal{A})$ ). \
Все возможные выборки должны быть равновероятны. 
Элементы входного набора считать попарно различными.